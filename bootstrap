#!/bin/sh

# set -euo pipefail

date +%s

export PATH=$PATH:/var/task

export TMP=/tmp
export HOME=$TMP
mkdir -p $HOME
mkdir -p $HOME/.cache
mkdir -p $HOME/.config

export XDG_RUNTIME_DIR=$HOME
export XDG_CONFIG_DIR=$HOME
export XDG_RUNTIME_USER=$HOME
export KEYBASE_SERVICE_ARGS="-use-default-log-file"
export KEYBASE_KBFS_ARGS="-log-to-file -mount-type=none -mode=constrained -runtime-dir=$HOME -storage-root=$HOME"

# jwt=$( cat $INPUT_FILE_PATH | jq '.jwt' )

# humm_jwt_check --jwt=$jwt --pubkey=$HIVE_PUBKEY
# jwt_valid=$?
# if (( $jwt_valid > 0 )) ; then
#  exit $jwt_valid
# fi

mkdir -p $HOME/.config/procs
procs --config > ~/.config/procs/config.toml
procs
procs | grep -i /usr/local/bin/kbfsfuse | grep -qv grep

# if kbfsfuse process exits with a match then grep will have a 0 exit code
KBFSFUSE_NOT_RUNNING=$?

echo $KBFSFUSE_NOT_RUNNING

if ! (( $KBFSFUSE_NOT_RUNNING == 0 )); then
 echo 'starting services'

 keybase $KEYBASE_SERVICE_ARGS service &

 echo 'starting kbfsfuse'

 kbfsfuse $KEYBASE_KBFS_ARGS &

 echo 'waiting'

 keybase ctl wait --include-kbfs
fi

echo 'baz'

keybase status | grep -i 'logged in:' | grep -iq 'no'
# if logged in then finding 'no' will have a 0 exit code
LOGGED_IN=$?
if (( $LOGGED_IN == 0 )) ; then
 echo 'logging in'
 keybase --no-auto-fork --no-debug oneshot
fi

# @todo - increase the parallelization in xargs
# would speed things up for many files but needs better output logic
# specifically, parallel output to a single file interleaves each line which is
# very bad obviously
echo 'reading fs'
keybase fs ls -1 -a --rec $HIVE_KEYBASE_PATH | grep .json | xargs -n 1 -P 1 -I "{}" keybase fs read $HIVE_KEYBASE_PATH/{} > $TMP/items.json

echo 'catting result'
cat $TMP/items.json
cat $TMP/items.json | jq -n '.items |= [inputs]'

echo 'fin'

date +%s

curl -X POST "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/response"  -d "z"
